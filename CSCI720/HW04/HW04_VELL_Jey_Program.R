
dfDecisionTree <<- data.frame(matrix(ncol = 1, nrow = 0))



loadAndProcess <- function(pathOfThefile){
  # This file doesn't have any header
  df <- read.csv(pathOfThefile, header = TRUE)
  df <- df[,colSums(is.na(df)) == 0]
  totNumberOfRows <- ncol(df)
  df$Totals <- rowSums(df[,c(2:totNumberOfRows)]) 
  return (df)
}

findNextUnusedRowIndex <- function(){
  rowCount <- length(dfDecisionTree)
  #print(c(" Decision Tree $$$%%^^^", rowCount))
  for (i in 1: rowCount){
    if(dfDecisionTree[[i]][["Used"]] == "F")
      return(i)
  }
  return(0)
}

getAccuracy <- function(df, type){
  df <- as.data.frame(df)
  #print(c("Accuracy Type : ", type))
  predicatedCount <- nrow(df[tolower(substr(df[,1],1,1)) == substr(type,1,1),])
  totalCount <- nrow(df)
  accuracy <- (predicatedCount/totalCount) *100
  return(accuracy)
}
findTheBestAttributeForParentNode <- function()
  {
  nextIndex <- findNextUnusedRowIndex()
  #print(c("Next Index : ", nextIndex, " Type of next Index", typeof(nextIndex)))
  if(as.numeric(nextIndex) > 0){
    
    df <- as.data.frame(dfDecisionTree[[nextIndex]][["NodeDF"]])
    #print(c("New DataFrame .... ", df))
  }
  noOfCols <- ncol(df) - 1
  outputdf <<- data.frame(matrix(ncol=6,nrow=0))
  
  colMedians <- data.frame(matrix(ncol = 2, nrow = 0))
  colnames(colMedians) <-  c("ColIndex", "Median")
  lNode.Name <- ""
  rNode.Name <- ""
  counter <- 1
  previousWeightedGini <- 1
  for(i in 2: noOfCols){
    medianVal <- median(df[,i])
    colMedians[counter,"ColIndex"] <- i
    colMedians[counter, "Median"] <- medianVal
    leftNode <- df[df[,i] < medianVal,]
    
    rightNode <- df[df[,i] >= medianVal,]

    totalLCount <- nrow(leftNode)
    lCupCakeCount <- nrow(leftNode[tolower(substr(leftNode[,1],1,1)) == "c",])
    #print(c("For Index : ", i , " LCupcake Count: ", lCupCakeCount, " LMuffin count : ", (totalLCount-lCupCakeCount)))
    totalRCount <- nrow(rightNode)
    rCupCakeCount <- nrow(rightNode[tolower(substr(rightNode[,1],1,1)) == "c",])
    #print(c("For Index : ", i ," RCupcake Count: ", rCupCakeCount, " RMuffin count : ", (totalRCount-rCupCakeCount)))
    if(lCupCakeCount > (totalLCount-lCupCakeCount)){
      lNodeName <- "cupcake"
      rNodeName <- "muffin"
    }else if(rCupCakeCount > (totalLCount-rCupCakeCount)) {
      
      lNodeName <- "muffin"
      rNodeName <- "cupcake"
    } else{
      lNodeName <- "cupckage"
      rNodeName <- "muffin"      
    }
    lGiniIndex <- 1 - (lCupCakeCount/totalLCount)^2 - ((totalLCount-lCupCakeCount)/totalLCount)^2
    rGiniIndex <- 1 - (rCupCakeCount/totalRCount)^2 - ((totalRCount-rCupCakeCount)/totalRCount)^2
    weightGiniIndex <- (totalLCount/(totalLCount + totalRCount))*lGiniIndex + 
                       (totalRCount/(totalLCount + totalRCount))*rGiniIndex
   
    if(totalLCount > 0 && totalRCount > 0) {
      if(previousWeightedGini > weightGiniIndex){
        #colnames(outputdf)<<- c("colIndex", "leftNodeName", "rightNodeName", "leftNode", "rightNode", "medVal")
        outputdf<<- c("colIndex"=i, "leftNodeName"=lNodeName, "rightNodeName"=rNodeName, "leftNode"=list(leftNode), "rightNode"=list(rightNode), "medVal"=medianVal)
        #print(c("colIndex"= i, "left Gini : " , lGiniIndex, " right Gini Index : ", rGiniIndex, " Weighted GiniIndex : ", weightGiniIndex))
        #print(c("Column Index : ", i, "LeftNodeName ",lNodeName, "RightNodeName ", rNodeName, "LeftNode ", leftNode , "RightNode ", rightNode , "SpiltCondition : ", medianVal))
        previousWeightedGini <- weightGiniIndex
      }
    }



    
    
    counter <- counter + 1
  }
  
  #dfCupcake <- df[df$Type == "Cupcake",]
  #dfMuffin <- df[df$Type == "Muffin",]
  #print(c("output df is ", length(outputdf)) )
  dfDecisionTree[[nextIndex]][["Used"]] <<- "T"
  dfDecisionTree[[nextIndex]][["Median"]] <<- outputdf[["medVal"]]
  dfDecisionTree[[nextIndex]][["sCond"]] <<- outputdf[["colIndex"]]   
  
  leftNodeAccuracy <- getAccuracy(outputdf[["leftNode"]], outputdf[["leftNodeName"]])
  #print(c("Left node accuracy is : ", leftNodeAccuracy))
  
  rightNodeAccuracy <- getAccuracy(outputdf[["rightNode"]], outputdf[["rightNodeName"]])
  #print(c("Right node accuracy is : ", rightNodeAccuracy))
  
  
  noOfIfs <- length(dfDecisionTree)
  #Define Left Node 
  if(noOfIfs <8){
    if(leftNodeAccuracy >= 98){
      leftNode <- c(NodeType ="F", Class=outputdf[["leftNodeName"]], Used="T", Median=-1,sCond=-1 , NodeDir="Left",NodeDF=list(outputdf[["leftNode"]]))
    }else{
      leftNode <- c(NodeType ="B", Class=outputdf[["leftNodeName"]], Used="F", Median=-1,sCond=-1 , NodeDir="Left",NodeDF=list(outputdf[["leftNode"]]))
    }
    dfDecisionTree[[length(dfDecisionTree) + 1]]<<- leftNode
  }else{
    return(0)
  }
  
 
  
  #Define the Right Node
 if(noOfIfs <8){
    if(rightNodeAccuracy >= 98){
      rightNode <- c(NodeType ="F", Class=outputdf[["rightNodeName"]], Used="T", Median=-1,sCond=-1 , NodeDir="Right",NodeDF=list(outputdf[["rightNode"]]))
    }else{
     rightNode <- c(NodeType ="B", Class=outputdf[["rightNodeName"]], Used="F", Median=-1,sCond=-1 , NodeDir="Right",NodeDF=list(outputdf[["rightNode"]]))
    }
    dfDecisionTree[[length(dfDecisionTree) + 1]]<<- rightNode
 }else{
    return (0)
  }

  findTheBestAttributeForParentNode()
  return (0)
  
}



dataCleaning <- function(df){
  noOfCols <- ncol(df)
  outlierRecords  <- c()
  for(i in 2: noOfCols){
    
    quantVals <- quantile(df[,i])
    iqrVal <- IQR(df[,i])
    q1 <- quantVals[2]
    q3 <- quantVals[4]

    upperInnerFence <- q1 - 3*iqrVal
    lowerInnerFence <- q1 - 1.5*iqrVal
    lowerOuterFence <- q3 + 1.5*iqrVal
    upperOuterFence <- q3 + 3*iqrVal
    if(upperOuterFence ==0){
      upperOuterFence = 5
    }
    belowLowerInnerFenceRowIndexes <- which(df[,i] < lowerInnerFence)
    belowUpperInnerFenceRowIndexes <- which(df[,i] < upperInnerFence)
    aboveLowerOuterFenceRowIndexes <- which(df[,i] > lowerOuterFence)
    aboveUpperOuterFenceRowIndexes <- which(df[,i] > upperOuterFence)
    #print(c("Column Index is : ", i , " upperInnerFence : " ,upperInnerFence , " : belowUpperInnerFenceRowIndexes : ", belowUpperInnerFenceRowIndexes))
    #print(c("Column Index is : ", i , "upperOuterFence : ",  upperOuterFence , " : aboveUpperOuterFenceRowIndexes : ", aboveUpperOuterFenceRowIndexes))
    outlierRecords <- c(outlierRecords, as.numeric(belowUpperInnerFenceRowIndexes), as.numeric(aboveUpperOuterFenceRowIndexes))
  }
  #print(c(" The outlier are : ", outlierRecords))
  #print(c(" The type of vector is  : ", is.numeric(outlierRecords) ))
  #print(c(" Before Record Count : ",nrow(df) ))
  if(length(outlierRecords) >0){
    df <- df[-outlierRecords,]
  }
  
  #print(c(" After Record Count : ",nrow(df) ))
  index <- which(duplicated(df))
  deduped.data <- unique(df)
  
  
  return (deduped.data)
}

#Generate Code to Generate DecisionTree

createTreeValidation <- function(){
  # install.packages("rstudioapi") # run this if it's your first time using it to install
  library(rstudioapi) # load it
  # the following line is for getting the path of your current open file
  current_path <- getActiveDocumentContext()$path 
  # The next line set the working directory to the relevant one:
  setwd(dirname(current_path ))
  #Creating an R source Code
  sink('HW_06_Vell_Jey_Classifie.R')

  cat("#Function to load the validaiton file \n")
  cat("loadFile <- function(pathOfThefile) { \n")
  cat("\tdf <- read.csv(pathOfThefile, header = TRUE)\n")
  cat("\tdf <- df[,colSums(is.na(df)) == 0]\n")
  cat("\ttotNumberOfRows <- ncol(df)\n")
  cat("\treturn(df)\n")
  cat("}\n")
  
  cat("#Function for classification\n")
  cat("classifier <-function(inputVal, id){ \n")
  cat("\tif(inputVal[2] < 40.285){ \n")
  cat("\t\tprint(c(id, \": classification is \", \"cupcake\", \" -LN\")) \n")
  cat("\t}else if(inputVal[2] < 46.26){ \n")
  cat("\t\tif(inputVal[6]<8){ \n")
  cat("\t\t\tprint(c(id, \": classification is \", \"Muffin\", \" - RN-LN-LN\")) \n")
  cat("\t\t}else { \n")
  cat("\t\t\tprint(c(id, \": classification is \", \"cupcake\", \" - RN-LN-RN\")) \n")
  cat("\t\t}\n")
  cat("\t}else{\n")
  cat("\t\tif (inputVal[6] < 5){ # RN-RN\n")
  cat("\t\t\tprint(c(id, \": classification is \", \"cupcake\", \" - RN-RN-LN\")) \n")
  cat("\t\t}else{ \n")
  cat("\t\t\tprint(c(id, \": classification is \", \"Muffin\", \" - RN-RN-RN\")) \n")
  cat("\t\t} \n")
  cat("\t} \n")
  cat("}\n")
  
  cat("#Main Function \n")
  cat("main <- function() { \n")
  cat("#Function to load the validaiton file \n")
  cat("\tfile_path <-\"/Users/jeyvell/BigDataCertification/CSCI720/HW04/Recipes_For_VALIDATION_2175_RELEASED_v201.csv\"\n")
  cat("\tdf <- loadFile(file_path) \n")
  cat("\ttotRows <- nrow(df)\n")
  cat("\tfor( i in 1:totRows) { \n")
  cat("\t\t classifier(df[i,], i)\n")
  cat("\t} \n")
  cat("}\n")
  # Stop writing to the file
  cat("call <- main() \n")
  sink()
  
}



main <- function(){
  library(ggplot2)
  library(grid)
  library(gridExtra)
  require(gridExtra)


  ###
  ##  IMPORTANT  ####
  ### PLEASE CHANGE THE FOLLOWING FILE PATH TO THE RIGHT LOCATION
  ####
  file_path <- "/Users/jeyvell/BigDataCertification/CSCI720/HW04/Recipes_For_Release_2175_v201.csv"
  newDataFrame <- loadAndProcess(file_path)
  #print(newDataFrame)
  afterCleaningDF <- dataCleaning (newDataFrame)
  #print(c("after deduplication : ", afterCleaningDF))
  dfCupcake <- afterCleaningDF[tolower(substr(afterCleaningDF$Type,1,1)) == "c",]
  dfMuffin <- afterCleaningDF[tolower(substr(afterCleaningDF$Type,1,1 ))== "m",]
  #dataCleaning (newDataFrame)
  #print(dfCupcake)
  
  #print(dfMuffin)
  #print(c(" Cupcake meidan is", median(dfCupcake[,6])))
  
  #print(c( " Muffin median is ", median(dfMuffin[,6])))
  #print(c("Real median is", median(afterCleaningDF[,6])))
  
  #print(c("#########$$$$$$$$$###########", afterCleaningDF))
  

  rootNode <<- c(NodeType ="T", Class="NA", Used="F", Median=-1,sCond=-1 , NodeDir="Root",NodeDF=list(afterCleaningDF))
  #print(c("ROOT NODE Type", nrow(rootNode$NodeDF)))
  dfDecisionTree<<- c(list(rootNode))

  #print(str(dfDecisionTree))
  #print(c("length of tree", length(dfDecisionTree)))
  #print(c("Find the node is used or not ", dfDecisionTree[[1]][[3]]))
  #dfDecisionTree[[1]][[4]] <<- 100 
  #print(c("Find the node is used or not ", dfDecisionTree[[1]][["Median"]]))
  findTheBestAttributeForParentNode()
  createTreeValidation()
  #plot(p1)
}



# Executing the main function
call <- main()
